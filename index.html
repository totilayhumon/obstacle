<!DOCTYPE html>
<html>
<head>
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
    <title>Obstacle Avoidance Game - Environmental Scenery</title>
</head>
<body>
    <a-scene background="color: #87CEEB" 
             vr-mode-ui="enabled: true"
             device-orientation-permission-ui="enabled: false">
        
        <!-- Player rig for VR movement -->
        <a-entity id="rig" 
                  movement-controls="fly: false; constrainToNavMesh: false"
                  position="0 0 0">
            
            <!-- VR Camera -->
            <a-camera id="camera" 
                      position="0 1.6 0"
                      look-controls="pointerLockEnabled: false"
                      wasd-controls="enabled: false">
                
                <!-- HUD Elements attached to camera -->
                <a-text id="scoreText" 
                        position="-1.5 1.2 -3" 
                        value="Score: 0" 
                        color="white"
                        scale="2 2 2">
                </a-text>
                
                <!-- Crosshair for center reference -->
                <a-ring position="0 0 -2" 
                        radius-inner="0.01" 
                        radius-outer="0.02" 
                        color="white"
                        opacity="0.5">
                </a-ring>
                
                <!-- Game Over Screen -->
                <a-text id="gameOverText" 
                        position="0 0.5 -3" 
                        value="" 
                        color="red"
                        scale="3 3 3"
                        visible="false"
                        align="center">
                </a-text>
                
                <a-text id="finalScoreText" 
                        position="0 0 -3" 
                        value="" 
                        color="red"
                        scale="2 2 2"
                        visible="false"
                        align="center">
                </a-text>
                
                <a-text id="restartText" 
                        position="0 -0.5 -3" 
                        value="Desktop: Press R | VR: Squeeze both grips together" 
                        color="white"
                        scale="1.2 1.2 1.2"
                        visible="false"
                        align="center">
                </a-text>

                <!-- Instructions -->
                <a-text id="instructionsText" 
                        position="0 -1.2 -3" 
                        value="Desktop: A/D: Strafe | W/Space: Jump | S: Crouch" 
                        color="yellow"
                        scale="1 1 1"
                        align="center">
                </a-text>
                
                <!-- Speed indicator -->
                <a-text id="speedText" 
                        position="1.5 1.2 -3" 
                        value="Speed: 1.0x" 
                        color="cyan"
                        scale="1.5 1.5 1.5">
                </a-text>
                
                <!-- Level indicator -->
                <a-text id="levelText" 
                        position="0 1.5 -3" 
                        value="Level: Grassland" 
                        color="lime"
                        scale="1.5 1.5 1.5"
                        align="center">
                </a-text>
                
                <!-- VR Instructions (hidden initially) -->
                <a-text id="vrInstructionsText" 
                        position="0 -1.5 -3" 
                        value="VR: Thumbstick: Move | Triggers: Jump | Grips: Crouch" 
                        color="orange"
                        scale="1 1 1"
                        align="center"
                        visible="false">
                </a-text>
            </a-camera>
            
            <!-- Left VR Controller with full support -->
            <a-entity id="leftController"
                      oculus-touch-controls="hand: left"
                      vive-controls="hand: left"
                      windows-motion-controls="hand: left"
                      hand-controls="hand: left; handModelStyle: lowPoly; color: #ffcccc">
            </a-entity>
            
            <!-- Right VR Controller with full support -->
            <a-entity id="rightController"
                      oculus-touch-controls="hand: right"
                      vive-controls="hand: right" 
                      windows-motion-controls="hand: right"
                      hand-controls="hand: right; handModelStyle: lowPoly; color: #ccffcc">
            </a-entity>
        </a-entity>
        
        <!-- Player collision box (invisible) -->
        <a-box id="player" 
               position="0 1.6 0" 
               color="blue" 
               width="0.5" 
               height="1.8" 
               depth="0.5"
               visible="false">
        </a-box>
        
        <!-- Initial ground planes - these will be managed dynamically -->
        <a-plane id="ground1" 
                 position="0 0 0" 
                 rotation="-90 0 0" 
                 width="50" 
                 height="100" 
                 color="green"
                 repeat="25 50">
        </a-plane>
        
        <a-plane id="ground2" 
                 position="0 0 -100" 
                 rotation="-90 0 0" 
                 width="50" 
                 height="100" 
                 color="green"
                 repeat="25 50">
        </a-plane>
        
        <a-plane id="ground3" 
                 position="0 0 -200" 
                 rotation="-90 0 0" 
                 width="50" 
                 height="100" 
                 color="green"
                 repeat="25 50">
        </a-plane>
        
    </a-scene>

    <script>
        // Wait for A-Frame to fully load
        document.addEventListener('DOMContentLoaded', function() {
            // Game variables
            let score = 0;
            let gameRunning = false;
            let obstacles = [];
            let sceneryObjects = []; // New array for scenery
            let playerSpeed = 0.12;
            let obstacleSpeed = 0.12;
            let scoreInterval;
            let obstacleInterval;
            let gameLoopInterval;
            let sceneryInterval; // New interval for scenery
            
            // Ground management
            let groundPlanes = [];
            let nextGroundZ = -300; // Next position to place ground
            let currentGroundColor = 'green';
            let currentLevel = 0;
            
            // Level system with colors, names, and scenery
            const levels = [
                { threshold: 0, color: 'green', name: 'Grassland', skyColor: '#87CEEB', scenery: 'trees' },
                { threshold: 1000, color: 'yellow', name: 'Desert', skyColor: '#F4A460', scenery: 'pyramids' },
                { threshold: 2500, color: 'orange', name: 'Canyon', skyColor: '#FF6347', scenery: 'hills' },
                { threshold: 4500, color: 'brown', name: 'Mountain', skyColor: '#8B4513', scenery: 'mountains' },
                { threshold: 7000, color: 'gray', name: 'Stone Valley', skyColor: '#696969', scenery: 'rocks' },
                { threshold: 10000, color: 'purple', name: 'Crystal Cave', skyColor: '#4B0082', scenery: 'crystals' },
                { threshold: 15000, color: 'blue', name: 'Ice Realm', skyColor: '#4169E1', scenery: 'ice' },
                { threshold: 22000, color: 'red', name: 'Lava Fields', skyColor: '#8B0000', scenery: 'volcanoes' },
                { threshold: 30000, color: 'black', name: 'Shadow Realm', skyColor: '#1C1C1C', scenery: 'portals' },
                { threshold: 50000, color: 'gold', name: 'Golden Paradise', skyColor: '#FFD700', scenery: 'coins' }
            ];
            
            // Player variables
            let player = document.getElementById('player');
            let rig = document.getElementById('rig');
            let camera = document.getElementById('camera');
            let leftController = document.getElementById('leftController');
            let rightController = document.getElementById('rightController');
            
            let isJumping = false;
            let isCrouching = false;
            let playerX = 0;
            let playerY = 1.6;
            let playerZ = 0;
            let rigY = 0;
            
            // Player dimensions for collision detection
            let playerHeight = 1.8;
            let playerWidth = 0.5;
            let playerDepth = 0.5;
            
            // VR state tracking
            let isVR = false;
            let leftControllerData = {};
            let rightControllerData = {};
            
            // Movement keys for desktop
            let keys = {
                left: false,
                right: false,
                jump: false,
                crouch: false
            };
            
            // Get all UI text elements
            let scoreText = document.getElementById('scoreText');
            let gameOverText = document.getElementById('gameOverText');
            let finalScoreText = document.getElementById('finalScoreText');
            let restartText = document.getElementById('restartText');
            let instructionsText = document.getElementById('instructionsText');
            let vrInstructionsText = document.getElementById('vrInstructionsText');
            let speedText = document.getElementById('speedText');
            let levelText = document.getElementById('levelText');
            
            // Obstacle shapes and colors arrays
            const shapeTypes = ['box', 'sphere', 'cylinder', 'cone', 'dodecahedron', 'octahedron'];
            const colors = ['red', 'orange', 'purple', 'maroon', 'darkred', 'crimson'];
            
            // Initialize ground planes array
            function initializeGround() {
                groundPlanes = [
                    document.getElementById('ground1'),
                    document.getElementById('ground2'),
                    document.getElementById('ground3')
                ];
            }
            
            // Create scenery based on current level
            function createScenery(sceneryType, x, z) {
                let scenery;
                
                switch(sceneryType) {
                    case 'trees':
                        // Create tree with trunk and leaves
                        scenery = document.createElement('a-entity');
                        let trunk = document.createElement('a-cylinder');
                        trunk.setAttribute('position', '0 1.5 0');
                        trunk.setAttribute('height', '3');
                        trunk.setAttribute('radius', '0.3');
                        trunk.setAttribute('color', '#8B4513');
                        
                        let leaves = document.createElement('a-sphere');
                        leaves.setAttribute('position', '0 3.5 0');
                        leaves.setAttribute('radius', '1.5');
                        leaves.setAttribute('color', '#228B22');
                        
                        scenery.appendChild(trunk);
                        scenery.appendChild(leaves);
                        break;
                        
                    case 'pyramids':
                        scenery = document.createElement('a-cone');
                        scenery.setAttribute('radius-bottom', '3');
                        scenery.setAttribute('height', '6');
                        scenery.setAttribute('color', '#DAA520');
                        scenery.setAttribute('position', `0 3 0`);
                        break;
                        
                    case 'hills':
                        scenery = document.createElement('a-sphere');
                        scenery.setAttribute('radius', '4');
                        scenery.setAttribute('color', '#CD853F');
                        scenery.setAttribute('position', `0 2 0`);
                        scenery.setAttribute('scale', '1 0.5 1');
                        break;
                        
                    case 'mountains':
                        scenery = document.createElement('a-cone');
                        scenery.setAttribute('radius-bottom', '5');
                        scenery.setAttribute('height', '10');
                        scenery.setAttribute('color', '#696969');
                        scenery.setAttribute('position', `0 5 0`);
                        break;
                        
                    case 'rocks':
                        scenery = document.createElement('a-dodecahedron');
                        scenery.setAttribute('radius', '2');
                        scenery.setAttribute('color', '#A9A9A9');
                        scenery.setAttribute('position', `0 2 0`);
                        scenery.setAttribute('animation', 'property: rotation; to: 0 360 0; loop: true; dur: 20000');
                        break;
                        
                    case 'crystals':
                        scenery = document.createElement('a-octahedron');
                        scenery.setAttribute('radius', '2.5');
                        scenery.setAttribute('color', '#9932CC');
                        scenery.setAttribute('position', `0 2.5 0`);
                        scenery.setAttribute('animation', 'property: rotation; to: 360 360 360; loop: true; dur: 3000');
                        break;
                        
                    case 'ice':
                        scenery = document.createElement('a-cone');
                        scenery.setAttribute('radius-bottom', '2');
                        scenery.setAttribute('height', '8');
                        scenery.setAttribute('color', '#B0E0E6');
                        scenery.setAttribute('position', `0 4 0`);
                        scenery.setAttribute('opacity', '0.8');
                        break;
                        
                    case 'volcanoes':
                        // Create volcano with lava glow
                        scenery = document.createElement('a-entity');
                        let volcanoBase = document.createElement('a-cone');
                        volcanoBase.setAttribute('radius-bottom', '4');
                        volcanoBase.setAttribute('height', '8');
                        volcanoBase.setAttribute('color', '#8B0000');
                        volcanoBase.setAttribute('position', '0 4 0');
                        
                        let lavaGlow = document.createElement('a-sphere');
                        lavaGlow.setAttribute('radius', '1');
                        lavaGlow.setAttribute('color', '#FF4500');
                        lavaGlow.setAttribute('position', '0 8 0');
                        lavaGlow.setAttribute('animation', 'property: scale; to: 1.5 1.5 1.5; dir: alternate; loop: true; dur: 1000');
                        
                        scenery.appendChild(volcanoBase);
                        scenery.appendChild(lavaGlow);
                        break;
                        
                    case 'portals':
                        scenery = document.createElement('a-torus');
                        scenery.setAttribute('radius', '3');
                        scenery.setAttribute('radius-tubular', '0.5');
                        scenery.setAttribute('color', '#8A2BE2');
                        scenery.setAttribute('position', `0 3 0`);
                        scenery.setAttribute('rotation', '90 0 0');
                        scenery.setAttribute('animation', 'property: rotation; to: 90 360 0; loop: true; dur: 4000');
                        break;
                        
                    case 'coins':
                        scenery = document.createElement('a-cylinder');
                        scenery.setAttribute('radius', '1');
                        scenery.setAttribute('height', '0.2');
                        scenery.setAttribute('color', '#FFD700');
                        scenery.setAttribute('position', `0 2 0`);
                        scenery.setAttribute('rotation', '0 0 90');
                        scenery.setAttribute('animation', 'property: rotation; to: 0 360 90; loop: true; dur: 2000');
                        break;
                        
                    default:
                        scenery = document.createElement('a-box');
                        scenery.setAttribute('width', '1');
                        scenery.setAttribute('height', '1');
                        scenery.setAttribute('depth', '1');
                        scenery.setAttribute('color', 'gray');
                        scenery.setAttribute('position', `0 0.5 0`);
                }
                
                // Set final position for scenery
                scenery.setAttribute('position', `${x} ${scenery.getAttribute('position').y} ${z}`);
                
                return scenery;
            }
            
            // Spawn scenery objects
            function spawnScenery() {
                if (!gameRunning) return;
                
                let currentLevelData = levels[currentLevel];
                let sceneryType = currentLevelData.scenery;
                
                // Spawn scenery on both sides of the path
                for (let i = 0; i < 2; i++) {
                    let side = i === 0 ? -1 : 1; // Left or right side
                    let xPos = side * (12 + Math.random() * 8); // 12-20 units from center
                    let zPos = playerZ - (20 + Math.random() * 30); // Spawn ahead
                    
                    let scenery = createScenery(sceneryType, xPos, zPos);
                    document.querySelector('a-scene').appendChild(scenery);
                    
                    sceneryObjects.push({
                        element: scenery,
                        position: {x: xPos, y: 0, z: zPos}
                    });
                }
            }
            
            // Clean up old scenery objects
            function updateScenery() {
                for (let i = sceneryObjects.length - 1; i >= 0; i--) {
                    let sceneryObj = sceneryObjects[i];
                    let scenery = sceneryObj.element;
                    
                    if (!scenery || !scenery.parentNode) {
                        sceneryObjects.splice(i, 1);
                        continue;
                    }
                    
                    let pos = scenery.getAttribute('position');
                    if (pos && pos.z > playerZ + 50) {
                        scenery.remove();
                        sceneryObjects.splice(i, 1);
                    }
                }
            }
            
            // Get current level based on score
            function getCurrentLevel() {
                for (let i = levels.length - 1; i >= 0; i--) {
                    if (score >= levels[i].threshold) {
                        return i;
                    }
                }
                return 0;
            }
            
            // Update level and ground color
            function updateLevel() {
                let newLevel = getCurrentLevel();
                if (newLevel !== currentLevel) {
                    currentLevel = newLevel;
                    let levelData = levels[currentLevel];
                    currentGroundColor = levelData.color;
                    
                    // Update level text
                    levelText.setAttribute('value', `Level: ${levelData.name}`);
                    levelText.setAttribute('color', levelData.color);
                    
                    // Change sky color
                    document.querySelector('a-scene').setAttribute('background', `color: ${levelData.skyColor}`);
                    
                    // Update all existing ground planes
                    groundPlanes.forEach(ground => {
                        if (ground && ground.parentNode) {
                            ground.setAttribute('color', currentGroundColor);
                        }
                    });
                    
                    console.log(`Level up! Now in: ${levelData.name} with ${levelData.scenery}`);
                }
            }
            
            // Manage infinite ground with current color
            function updateGround() {
                // Check if we need to add more ground ahead
                while (nextGroundZ > playerZ - 300) {
                    let newGround = document.createElement('a-plane');
                    newGround.setAttribute('position', `0 0 ${nextGroundZ}`);
                    newGround.setAttribute('rotation', '-90 0 0');
                    newGround.setAttribute('width', '50');
                    newGround.setAttribute('height', '100');
                    newGround.setAttribute('color', currentGroundColor);
                    newGround.setAttribute('repeat', '25 50');
                    
                    document.querySelector('a-scene').appendChild(newGround);
                    groundPlanes.push(newGround);
                    nextGroundZ -= 100; // Move to next position
                }
                
                // Remove ground planes that are far behind the player
                for (let i = groundPlanes.length - 1; i >= 0; i--) {
                    let ground = groundPlanes[i];
                    if (ground && ground.parentNode) {
                        let pos = ground.getAttribute('position');
                        if (pos && pos.z > playerZ + 200) {
                            ground.remove();
                            groundPlanes.splice(i, 1);
                        }
                    } else {
                        groundPlanes.splice(i, 1);
                    }
                }
            }
            
            // VR detection and controller setup
            function setupVR() {
                // Detect when entering/exiting VR mode
                document.querySelector('a-scene').addEventListener('enter-vr', () => {
                    console.log('Entered VR mode');
                    isVR = true;
                    updateInstructionsForVR();
                });
                
                document.querySelector('a-scene').addEventListener('exit-vr', () => {
                    console.log('Exited VR mode');
                    isVR = false;
                    updateInstructionsForDesktop();
                });
                
                // Left controller event listeners
                if (leftController) {
                    leftController.addEventListener('thumbstickmoved', handleLeftThumbstick);
                    leftController.addEventListener('triggerdown', handleLeftTrigger);
                    leftController.addEventListener('gripdown', handleLeftGrip);
                    leftController.addEventListener('gripup', handleLeftGripUp);
                }
                
                // Right controller event listeners
                if (rightController) {
                    rightController.addEventListener('thumbstickmoved', handleRightThumbstick);
                    rightController.addEventListener('triggerdown', handleRightTrigger);
                    rightController.addEventListener('gripdown', handleRightGrip);
                    rightController.addEventListener('gripup', handleRightGripUp);
                }
            }
            
            // VR Controller event handlers
            function handleLeftThumbstick(event) {
                leftControllerData.thumbstick = event.detail;
            }
            
            function handleRightThumbstick(event) {
                rightControllerData.thumbstick = event.detail;
            }
            
            function handleLeftTrigger() {
                if (gameRunning && !isJumping && !isCrouching) {
                    jump();
                }
            }
            
            function handleRightTrigger() {
                if (gameRunning && !isJumping && !isCrouching) {
                    jump();
                }
            }
            
            function handleLeftGrip() {
                if (gameRunning && !isJumping) {
                    startCrouch();
                }
                leftControllerData.grip = true;
                checkForVRRestart();
            }
            
            function handleLeftGripUp() {
                if (gameRunning) {
                    stopCrouch();
                }
                leftControllerData.grip = false;
            }
            
            function handleRightGrip() {
                if (gameRunning && !isJumping) {
                    startCrouch();
                }
                rightControllerData.grip = true;
                checkForVRRestart();
            }
            
            function handleRightGripUp() {
                if (gameRunning) {
                    stopCrouch();
                }
                rightControllerData.grip = false;
            }
            
            // Check if both grips are pressed for VR restart
            function checkForVRRestart() {
                if (!gameRunning && leftControllerData.grip && rightControllerData.grip) {
                    obstacles.forEach(obstacleObj => {
                        if (obstacleObj.element && obstacleObj.element.parentNode) {
                            obstacleObj.element.remove();
                        }
                    });
                    obstacles = [];
                    
                    // Clean up scenery too
                    sceneryObjects.forEach(sceneryObj => {
                        if (sceneryObj.element && sceneryObj.element.parentNode) {
                            sceneryObj.element.remove();
                        }
                    });
                    sceneryObjects = [];
                    
                    startGame();
                }
            }
            
            // Movement functions with proper collision box updates
            function jump() {
                if (isJumping || isCrouching) return;
                isJumping = true;
                
                if (isVR) {
                    rigY = 1.2;
                    rig.setAttribute('position', `${playerX} ${rigY} ${playerZ}`);
                    playerY = 1.6 + rigY;
                } else {
                    playerY = 2.8;
                }
                
                setTimeout(() => {
                    if (gameRunning && isJumping) {
                        if (isVR) {
                            rigY = isCrouching ? -0.4 : 0;
                            rig.setAttribute('position', `${playerX} ${rigY} ${playerZ}`);
                            playerY = 1.6 + rigY;
                        } else {
                            playerY = isCrouching ? 1.2 : 1.6;
                        }
                        isJumping = false;
                    }
                }, 700);
            }
            
            function startCrouch() {
                if (isCrouching || isJumping) return;
                isCrouching = true;
                
                if (isVR) {
                    rigY = -0.4;
                    rig.setAttribute('position', `${playerX} ${rigY} ${playerZ}`);
                    playerY = 1.6 + rigY;
                    playerHeight = 1.2;
                } else {
                    playerY = 1.2;
                    player.setAttribute('height', '1.2');
                    playerHeight = 1.2;
                }
            }
            
            function stopCrouch() {
                if (!isCrouching || isJumping) return;
                isCrouching = false;
                
                if (isVR) {
                    rigY = 0;
                    rig.setAttribute('position', `${playerX} ${rigY} ${playerZ}`);
                    playerY = 1.6;
                    playerHeight = 1.8;
                } else {
                    playerY = 1.6;
                    player.setAttribute('height', '1.8');
                    playerHeight = 1.8;
                }
            }
            
            function updateInstructionsForVR() {
                instructionsText.setAttribute('visible', false);
                vrInstructionsText.setAttribute('visible', true);
                restartText.setAttribute('value', 'VR: Squeeze both grips together to restart');
            }
            
            function updateInstructionsForDesktop() {
                instructionsText.setAttribute('visible', true);
                vrInstructionsText.setAttribute('visible', false);
                restartText.setAttribute('value', 'Desktop: Press R to restart');
            }
            
            // Start the game
            function startGame() {
                console.log('Starting game...');
                score = 0;
                gameRunning = true;
                obstacles = [];
                sceneryObjects = []; // Reset scenery
                playerSpeed = 0.12;
                obstacleSpeed = 0.12;
                currentLevel = 0;
                currentGroundColor = 'green';
                
                // Reset player position
                playerX = 0;
                playerY = 1.6;
                playerZ = 0;
                rigY = 0;
                playerHeight = 1.8;
                nextGroundZ = -300; // Reset ground spawning
                
                // Reset environment
                document.querySelector('a-scene').setAttribute('background', 'color: #87CEEB');
                levelText.setAttribute('value', 'Level: Grassland');
                levelText.setAttribute('color', 'lime');
                
                rig.setAttribute('position', `${playerX} ${rigY} ${playerZ}`);
                player.setAttribute('position', `${playerX} ${playerY} ${playerZ}`);
                player.setAttribute('height', '1.8');
                
                // Hide game over screen
                gameOverText.setAttribute('visible', false);
                finalScoreText.setAttribute('visible', false);
                restartText.setAttribute('visible', false);
                
                if (isVR) {
                    vrInstructionsText.setAttribute('visible', true);
                    instructionsText.setAttribute('visible', false);
                } else {
                    instructionsText.setAttribute('visible', true);
                    vrInstructionsText.setAttribute('visible', false);
                }
                
                // Reset player state
                isJumping = false;
                isCrouching = false;
                keys = { left: false, right: false, jump: false, crouch: false };
                leftControllerData = {};
                rightControllerData = {};
                
                // Clear any existing intervals
                if (scoreInterval) clearInterval(scoreInterval);
                if (obstacleInterval) clearInterval(obstacleInterval);
                if (gameLoopInterval) clearInterval(gameLoopInterval);
                if (sceneryInterval) clearInterval(sceneryInterval); // Clear scenery interval
                
                // Start score counter
                scoreInterval = setInterval(() => {
                    if (gameRunning) {
                        score += 10;
                        scoreText.setAttribute('value', 'Score: ' + score);
                        let speedMultiplier = 1 + (score * 0.00005);
                        playerSpeed = Math.min(0.25, 0.12 * speedMultiplier);
                        obstacleSpeed = Math.min(0.3, 0.12 * speedMultiplier);
                        speedText.setAttribute('value', 'Speed: ' + speedMultiplier.toFixed(1) + 'x');
                        
                        // Update level based on score
                        updateLevel();
                    }
                }, 100);
                
                // Start spawning obstacles more frequently
                obstacleInterval = setInterval(spawnObstacle, 1200);
                
                // Start spawning scenery
                sceneryInterval = setInterval(spawnScenery, 3000); // Spawn scenery every 3 seconds
                
                // Start game loop
                gameLoopInterval = setInterval(updateGame, 16); // ~60fps
            }
            
            // Spawn various shaped obstacles around the player area
            function spawnObstacle() {
                if (!gameRunning) return;
                
                // Spawn multiple obstacles at once sometimes
                let numObstacles = Math.random() > 0.7 ? 2 : 1;
                
                for (let i = 0; i < numObstacles; i++) {
                    let obstacle = document.createElement('a-' + shapeTypes[Math.floor(Math.random() * shapeTypes.length)]);
                    
                    // Spawn in a wider area around the player's path
                    let xPos = (Math.random() - 0.5) * 16; // Much wider spawn area (-8 to 8)
                    let zPos = playerZ - (15 + Math.random() * 15); // Spawn 15-30 units ahead
                                        let yPos = 0.5 + Math.random() * 2.5; // Random height between 0.5 and 3.0
                    
                    obstacle.setAttribute('position', `${xPos} ${yPos} ${zPos}`);
                    obstacle.setAttribute('color', colors[Math.floor(Math.random() * colors.length)]);
                    
                    // Set size based on shape type
                    let size = 0.8 + Math.random() * 1.2; // Random size between 0.8 and 2.0
                    
                    switch(obstacle.tagName.toLowerCase()) {
                        case 'a-box':
                            obstacle.setAttribute('width', size);
                            obstacle.setAttribute('height', size);
                            obstacle.setAttribute('depth', size);
                            break;
                        case 'a-sphere':
                            obstacle.setAttribute('radius', size * 0.7);
                            break;
                        case 'a-cylinder':
                            obstacle.setAttribute('radius', size * 0.6);
                            obstacle.setAttribute('height', size * 1.5);
                            break;
                        case 'a-cone':
                            obstacle.setAttribute('radius-bottom', size * 0.8);
                            obstacle.setAttribute('height', size * 1.5);
                            break;
                        default:
                            obstacle.setAttribute('radius', size * 0.7);
                    }
                    
                    obstacle.setAttribute('class', 'obstacle');
                    
                    // Add random rotation animation
                    let rotationAxis = ['x', 'y', 'z'][Math.floor(Math.random() * 3)];
                    let rotationSpeed = 2000 + Math.random() * 4000;
                    obstacle.setAttribute('animation', 
                        `property: rotation; to: ${rotationAxis === 'x' ? '360' : '0'} ${rotationAxis === 'y' ? '360' : '0'} ${rotationAxis === 'z' ? '360' : '0'}; loop: true; dur: ${rotationSpeed}`);
                    
                    document.querySelector('a-scene').appendChild(obstacle);
                    obstacles.push({
                        element: obstacle,
                        size: size,
                        position: {x: xPos, y: yPos, z: zPos}
                    });
                }
            }
            
            // FIXED COLLISION DETECTION
            function checkCollision(obstacleObj) {
                let obstacle = obstacleObj.element;
                let pos = obstacle.getAttribute('position');
                if (!pos) return false;
                
                // Get current player dimensions based on state
                let currentPlayerHeight = isCrouching ? 1.2 : 1.8;
                let playerBottom = playerY - (currentPlayerHeight / 2);
                let playerTop = playerY + (currentPlayerHeight / 2);
                
                // Get obstacle dimensions
                let obstacleSize = obstacleObj.size;
                let obstacleBottom = pos.y - (obstacleSize / 2);
                let obstacleTop = pos.y + (obstacleSize / 2);
                
                // Check X collision (left/right)
                let xCollision = Math.abs(pos.x - playerX) < (obstacleSize * 0.7 + playerWidth / 2);
                
                // Check Z collision (forward/backward)
                let zCollision = Math.abs(pos.z - playerZ) < (obstacleSize * 0.7 + playerDepth / 2);
                
                // Check Y collision (up/down)
                let yCollision = !(playerTop < obstacleBottom || playerBottom > obstacleTop);
                
                return xCollision && zCollision && yCollision;
            }
            
            // Update game logic
            function updateGame() {
                if (!gameRunning) return;
                
                // Move player forward automatically
                playerZ -= playerSpeed;
                
                // Update infinite ground
                updateGround();
                
                // Update scenery
                updateScenery();
                
                // Handle left/right movement
                if (isVR) {
                    // VR thumbstick movement
                    if (leftControllerData.thumbstick && Math.abs(leftControllerData.thumbstick.x) > 0.1) {
                        playerX += leftControllerData.thumbstick.x * 0.1;
                        playerX = Math.max(-8, Math.min(8, playerX));
                    }
                    if (rightControllerData.thumbstick && Math.abs(rightControllerData.thumbstick.x) > 0.1) {
                        playerX += rightControllerData.thumbstick.x * 0.1;
                        playerX = Math.max(-8, Math.min(8, playerX));
                    }
                } else {
                    // Desktop movement
                    if (keys.left && playerX > -8) {
                        playerX -= 0.15;
                    }
                    if (keys.right && playerX < 8) {
                        playerX += 0.15;
                    }
                }
                
                // Update positions
                if (isVR) {
                    rig.setAttribute('position', `${playerX} ${rigY} ${playerZ}`);
                    playerY = 1.6 + rigY;
                } else {
                    player.setAttribute('position', `${playerX} ${playerY} ${playerZ}`);
                    camera.setAttribute('position', `${playerX} ${playerY} ${playerZ}`);
                }
                
                // Update obstacles and check collisions
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    let obstacleObj = obstacles[i];
                    let obstacle = obstacleObj.element;
                    
                    if (!obstacle || !obstacle.parentNode) {
                        obstacles.splice(i, 1);
                        continue;
                    }
                    
                    let pos = obstacle.getAttribute('position');
                    if (!pos) continue;
                    
                    // Remove obstacles that are far behind player
                    if (pos.z > playerZ + 20) {
                        obstacle.remove();
                        obstacles.splice(i, 1);
                        continue;
                    }
                    
                    // Use the fixed collision detection
                    if (checkCollision(obstacleObj)) {
                        gameOver();
                        return;
                    }
                }
            }
            
            // Game over function
            function gameOver() {
                console.log('Game Over! Final Score:', score);
                gameRunning = false;
                
                // Clear intervals
                if (scoreInterval) clearInterval(scoreInterval);
                if (obstacleInterval) clearInterval(obstacleInterval);
                if (gameLoopInterval) clearInterval(gameLoopInterval);
                if (sceneryInterval) clearInterval(sceneryInterval);
                
                // Hide instructions
                instructionsText.setAttribute('visible', false);
                vrInstructionsText.setAttribute('visible', false);
                
                // Show game over screen
                gameOverText.setAttribute('value', 'GAME OVER!');
                gameOverText.setAttribute('visible', true);
                finalScoreText.setAttribute('value', 'Final Score: ' + score);
                finalScoreText.setAttribute('visible', true);
                restartText.setAttribute('visible', true);
            }
            
            // Keyboard controls for desktop
            document.addEventListener('keydown', (event) => {
                // Prevent default behavior for game keys
                if (['Space', 'KeyW', 'KeyS', 'KeyA', 'KeyD', 'KeyR'].includes(event.code)) {
                    event.preventDefault();
                }
                
                if (!gameRunning && event.key.toLowerCase() === 'r') {
                    // Remove all obstacles
                    obstacles.forEach(obstacleObj => {
                        if (obstacleObj.element && obstacleObj.element.parentNode) {
                            obstacleObj.element.remove();
                        }
                    });
                    obstacles = [];
                    
                    // Remove all scenery
                    sceneryObjects.forEach(sceneryObj => {
                        if (sceneryObj.element && sceneryObj.element.parentNode) {
                            sceneryObj.element.remove();
                        }
                    });
                    sceneryObjects = [];
                    
                    startGame();
                    return;
                }
                
                if (!gameRunning) return;
                
                // Movement keys
                if (event.key.toLowerCase() === 'a') keys.left = true;
                if (event.key.toLowerCase() === 'd') keys.right = true;
                
                // Jump (Space or W key)
                if ((event.code === 'Space' || event.key.toLowerCase() === 'w') && !isJumping && !isCrouching) {
                    jump();
                }
                
                // Crouch (S key)
                if (event.key.toLowerCase() === 's' && !isJumping && !isCrouching) {
                    startCrouch();
                }
            });
            
            document.addEventListener('keyup', (event) => {
                // Movement keys
                if (event.key.toLowerCase() === 'a') keys.left = false;
                if (event.key.toLowerCase() === 'd') keys.right = false;
                
                // Stop crouching
                if (event.key.toLowerCase() === 's' && isCrouching && !isJumping) {
                    stopCrouch();
                }
            });
            
            // Wait for scene to load, then setup VR and start game
            let scene = document.querySelector('a-scene');
            if (scene.hasLoaded) {
                initializeGround();
                setupVR();
                setTimeout(startGame, 1000);
            } else {
                scene.addEventListener('loaded', () => {
                    initializeGround();
                    setupVR();
                    setTimeout(startGame, 1000);
                });
            }
        });
    </script>
</body>
</html>
